import java.util.regex.Matcher
import org.gradle.crypto.checksum.Checksum

plugins {
    id 'java'
    id "org.gradle.crypto.checksum" version "1.4.0"
    id 'com.github.johnrengelman.shadow' version '8.1.1'
}

// ----------------------
// Java version & encoding
// ----------------------
java {
    sourceCompatibility = JavaVersion.VERSION_1_8
    targetCompatibility = JavaVersion.VERSION_1_8
}

tasks.withType(JavaCompile) {
    options.encoding = 'UTF-8'
}

// ----------------------
// Main class
// ----------------------
ext.mainClass = 'chatty.Chatty'

// ----------------------
// Repositories
// ----------------------
repositories {
    mavenCentral()
}

// ----------------------
// Source sets
// ----------------------
sourceSets {
    main {
        java { srcDirs = ['src'] }
        resources { srcDirs = ['src', 'src/main/resources'] }
    }
    test {
        java { srcDirs = ['test'] }
        resources { srcDirs = ['test'] }
    }
}

// ----------------------
// Version extraction
// ----------------------
def extractVersion = {
    File chattyClassFile = new File(sourceSets.main.java.srcDirs.first(), 'chatty/Chatty.java')
    Matcher matcher = chattyClassFile.text =~ /(?m)^\s*public static final String VERSION = "(.*?)";/
    return matcher[0][1]
}

version = extractVersion()

// ----------------------
// Dependencies
// ----------------------
dependencies {
    implementation fileTree(dir: 'assets/lib', include: ['*.jar'])
    implementation 'net.java.dev.jna:jna:5.12.1'
    implementation 'net.java.dev.jna:jna-platform:5.12.1'
    implementation 'com.formdev:flatlaf:3.2.5'
    implementation 'com.google.cloud:google-cloud-vertexai:1.33.0'
    implementation 'org.slf4j:slf4j-api:2.0.9'
    runtimeOnly 'ch.qos.logback:logback-classic:1.4.11'

    testImplementation 'junit:junit:4.12'
}

// ----------------------
// Jar & ShadowJar
// ----------------------
jar {
    manifest {
        attributes('Main-Class': mainClass)
    }
}

tasks.named('shadowJar') {
    archiveBaseName.set('Chatty')
    archiveClassifier.set('')
    archiveVersion.set('')

    manifest {
        inheritFrom(tasks.jar.get().manifest)
    }

    configurations = [project.configurations.runtimeClasspath]
    mergeServiceFiles()
}

// ----------------------
// Release Zips
// ----------------------
def releasesDir = file("$buildDir/releases")

task allPlatformsZip(type: Zip) {
    group = 'build'
    dependsOn shadowJar

    from(tasks.shadowJar.get().archiveFile.get().asFile)
    from('assets') {
        exclude 'lib', 'linux'
    }

    destinationDirectory = releasesDir
    archiveFileName.set("${tasks.shadowJar.get().archiveBaseName.get()}_${version}.zip")
}

task releaseZips {
    group = 'build'
    dependsOn allPlatformsZip
}

task release {
    group = 'build'
    dependsOn releaseZips, build
}

// ----------------------
// Windows Packaging
// ----------------------
def windowsBundleTarget = file("$buildDir/javapackager")
def windowsBundleSource = file("$windowsBundleTarget/Chatty")
def standaloneSuffix = "_legacy"
def isJPackage = false

if (project.hasProperty('jpackagePath')) {
    windowsBundleTarget = file("$buildDir/jpackage")
    windowsBundleSource = file("$windowsBundleTarget/Chatty")
    standaloneSuffix = ""
    isJPackage = true
}

ext.standaloneSuffix = standaloneSuffix
ext.isJPackageString = isJPackage ? "1" : "0"

task javapackagerBuild(type: Exec) {
    group = 'build'
    dependsOn shadowJar

    doFirst {
        if (!project.hasProperty('javapackagerPath') && !project.hasProperty('jpackagePath')) {
            throw new GradleException('Path to javapackager.exe must be defined with -PjavapackagerPath=<path>')
        }
        delete windowsBundleTarget
        copy {
            from tasks.shadowJar.get().archiveFile.get().asFile
            into "$windowsBundleTarget/input"
        }
    }

    doLast {
        if (project.hasProperty('jpackagePath')) {
            commandLine = [
                project.property('jpackagePath'),
                '--type', 'app-image',
                '-n', 'Chatty',
                '-i', "$windowsBundleTarget/input",
                '-d', windowsBundleTarget,
                '--main-class', 'chatty.Chatty',
                '--main-jar', 'Chatty.jar',
                '--description', 'Chatty - Twitch Chat Client',
                '--java-options', '-Xmx600M',
                '--java-options', '-Dsun.java2d.d3d=false',
                '--icon', 'assets-bundle/Chatty.ico',
                '--app-version', version.replace("-", ".").replace("b","0.")
            ]
        } else {
            commandLine = [
                project.property('javapackagerPath'),
                '-deploy', '-native', 'image',
                '-srcfiles', tasks.shadowJar.get().archiveFile.get().asFile,
                '-appclass', 'chatty.Chatty',
                '-outdir', windowsBundleTarget,
                '-outfile', 'Chatty',
                "-Bicon=assets-bundle/Chatty.ico",
                "-BappVersion=${version}",
                "-BjvmProperties=sun.java2d.d3d=false",
                "-BjvmOptions=-Xmx400M"
            ]
            if (project.hasProperty('jrePath')) {
                commandLine += ["-Bruntime=${project.property('jrePath')}"]
            }
        }
    }
}

task windowsZip(type: Zip) {
    group = 'build'
    dependsOn javapackagerBuild

    from windowsBundleSource
    from('assets') {
        exclude 'lib'
        into 'app'
    }
    from('assets-bundle/fallback-fonts') {
        into 'runtime/lib/fonts/fallback'
    }
    from('assets-bundle/readme-bundle.txt')

    destinationDirectory = releasesDir
    archiveFileName.set("${tasks.shadowJar.get().archiveBaseName.get()}_${version}_win_standalone${standaloneSuffix}.zip")
}

task releaseWindows {
    group = 'build'
    dependsOn release, windowsZip
}

// ----------------------
// Checksums
// ----------------------
task createChecksums(type: Checksum) {
    mustRunAfter(allPlatformsZip, windowsZip, releaseWindows)
    files = layout.files { releasesDir.listFiles() }.filter { it.name.endsWith('.exe') || it.name.endsWith('.zip') }
    outputDir = file("${releasesDir}/v${version}")
    algorithm = Checksum.Algorithm.SHA256
}
